import java.io.DataInputStream;
import java.net.ConnectException;
import java.net.Socket;
import java.text.DecimalFormat;

import org.apache.spark.SparkConf;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.examples.streaming.StreamingExamples;
import org.apache.spark.storage.StorageLevel;
import org.apache.spark.streaming.Duration;
import org.apache.spark.streaming.api.java.JavaDStream;
import org.apache.spark.streaming.api.java.JavaPairDStream;
import org.apache.spark.streaming.api.java.JavaReceiverInputDStream;
import org.apache.spark.streaming.api.java.JavaStreamingContext;
import org.apache.spark.streaming.receiver.Receiver;

import scala.Tuple2;

/**
 * @author Z.Y.T
 * 
 *         2014年10月20日下午2:30:37
 */
public class GPStreaming extends Receiver<String> {

	private static final long serialVersionUID = 1L;

	String host = null;
	int port = -1;

	// ========= Receiver code that receives data over a socket =========
	public GPStreaming(String host, int port) {
		super(StorageLevel.MEMORY_AND_DISK_2());
		this.host = host;
		this.port = port;
	}

	@Override
	public void onStart() {
		// Start the thread that receives data over a connection
		new Thread() {
			public void run() {
				receive();
			};
		}.start();
	}

	@Override
	public void onStop() {
		// There is nothing much to do as the thread calling receive()
		// is designed to stop by itself isStopped() returns false
	}

	/** Create a socket connection and receive data until receiver is stopped */
	private void receive() {
		Socket socket = null;
		String str = null;
		try {
			// connect to the server
			socket = new Socket(host, port);

			DataInputStream dis = new DataInputStream(socket.getInputStream());

			// Until stopped or connection broken continue reading
			while (!isStopped() && !(str = dis.readUTF()).equals("end")) {
				// System.out.println("Received data '" + str + "'");
				store(str);
			}
			dis.close();
			socket.close();

			// Restart in an attempt to connect again when server is active
			// again
			restart("Trying to connect again");
		} catch (ConnectException ce) {
			// restart if could not connect to server
			restart("Could not connect", ce);
		} catch (Throwable t) {
			restart("Error receiving data", t);
		}
	}

	@SuppressWarnings("serial")
	public static void main(String[] args) {
		System.setProperty("hadoop.home.dir", "I:\\zyt\\Desktop\\hadoop-2.5.1");
		StreamingExamples.setStreamingLogLevels();

		// final PathGraph_1 pg = new PathGraph_1();
		// pg.initRoad(new File("I:\\zyt\\Desktop\\Road.txt"));

		final PathGraph pg = new PathGraph();
		String path = "Road_2.0.txt";
		pg.initRoadNodes(path);

		String host = "localhost";
		int port = 11111;
		// Create the context with a 1 second batch size
		SparkConf sparkConf = new SparkConf().setAppName("GPStreaming")
				.setMaster("local[*]");
		JavaStreamingContext ssc = new JavaStreamingContext(sparkConf,
				new Duration(15000));

		// Create a JavaReceiverInputDStream on target ip:port and count the
		// words in input stream of \n delimited text (eg. generated by 'nc')
		// Note that no duplication in storage level only for running locally.
		// Replication necessary in distributed scenario for fault tolerance.
		JavaReceiverInputDStream<String> lines = ssc
				.receiverStream(new GPStreaming(host, port));

		JavaDStream<String> points = lines.map(new Function<String, String>() {
			@Override
			public String call(String line) throws Exception {
				// TODO Auto-generated method stub
				String value = pg.computeRoadNode(line);
				return value;
			}
		});
		points.print();
		points.mapToPair(
				new PairFunction<String, String, Tuple2<Double, Integer>>() {
					@Override
					public Tuple2<String, Tuple2<Double, Integer>> call(
							String arg0) throws Exception {
						// TODO Auto-generated method stub
						String[] s = arg0.split("\t");
						String road = s[0];
						Double speed = Double.parseDouble(s[2]);
						Tuple2<Double, Integer> tuple = new Tuple2<>(speed, 1);
						return new Tuple2<String, Tuple2<Double, Integer>>(
								road, tuple);
					}
				})
				.reduceByKey(
						new Function2<Tuple2<Double, Integer>, Tuple2<Double, Integer>, Tuple2<Double, Integer>>() {
							@Override
							public Tuple2<Double, Integer> call(
									Tuple2<Double, Integer> arg0,
									Tuple2<Double, Integer> arg1)
									throws Exception {
								// TODO Auto-generated method stub
								double speed = arg0._1 + arg1._1;
								int count = arg0._2 + arg1._2;
								return new Tuple2<Double, Integer>(speed, count);
							}
						});

		JavaPairDStream<String, Integer> count = points.mapToPair(
				new PairFunction<String, String, Integer>() {
					@Override
					public Tuple2<String, Integer> call(String arg0)
							throws Exception {
						// TODO Auto-generated method stub
						String[] s = arg0.split("\t");
						String road = s[0];
						return new Tuple2<String, Integer>(road, 1);
					}
				}).reduceByKey(new Function2<Integer, Integer, Integer>() {

			@Override
			public Integer call(Integer arg0, Integer arg1) throws Exception {
				// TODO Auto-generated method stub
				return arg0 + arg1;
			}
		});
		// count.print();

		JavaPairDStream<String, Double> result = points.mapToPair(
				new PairFunction<String, String, Double>() {
					@Override
					public Tuple2<String, Double> call(String str)
							throws Exception {
						// TODO Auto-generated method stub
						String[] s = str.split("\t");
						String road = s[0];
						Double speed = Double.parseDouble(s[2]);
						return new Tuple2<String, Double>(road, speed);
					}
				}).reduceByKey(new Function2<Double, Double, Double>() {
			@Override
			public Double call(Double arg0, Double arg1) throws Exception {
				// TODO Auto-generated method stub
				return arg0 + arg1;
			}
		});

		JavaPairDStream<String, String> result2 = result.join(count).mapValues(
				new Function<Tuple2<Double, Integer>, String>() {
					@Override
					public String call(Tuple2<Double, Integer> arg0)
							throws Exception {
						// TODO Auto-generated method stub
						// System.out.println("a1: " + arg0._1());
						// System.out.println("a2: " + arg0._2());
						String s=new DecimalFormat("0.0").format(arg0._1 / arg0._2);
						return s;
					}
				});
		result2.print();

		ssc.start();
		ssc.awaitTermination();
	}
}
